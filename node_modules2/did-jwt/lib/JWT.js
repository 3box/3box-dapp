'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolveAuthenticator = exports.verifyJWT = exports.createJWT = exports.IAT_SKEW = undefined;

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

/**
*  Creates a signed JWT given an address which becomes the issuer, a signer, and a payload for which the signature is over.
*
*  @example
*  const signer = SimpleSigner(process.env.PRIVATE_KEY)
*  createJWT({address: '5A8bRWU3F7j3REx3vkJ...', signer}, {key1: 'value', key2: ..., ... }).then(jwt => {
*      ...
*  })
*
*  @param    {Object}            payload            payload object
*  @param    {Object}            [config]           an unsigned credential object
*  @param    {String}            config.issuer      The DID of the issuer (signer) of JWT
*  @param    {String}            config.alg         The JWT signing algorithm to use. Supports: [ES256K, ES256K-R], Defaults to: ES256K
*  @param    {SimpleSigner}      config.signer      a signer, reference our SimpleSigner.js
*  @return   {Promise<Object, Error>}               a promise which resolves with a signed JSON Web Token or rejects with an error
*/
var createJWT = exports.createJWT = function () {
  var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(payload, _ref) {
    var issuer = _ref.issuer,
        signer = _ref.signer,
        alg = _ref.alg,
        expiresIn = _ref.expiresIn;
    var header, timestamps, signingInput, jwtSigner, signature;
    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (signer) {
              _context.next = 2;
              break;
            }

            throw new Error('No Signer functionality has been configured');

          case 2:
            if (issuer) {
              _context.next = 4;
              break;
            }

            throw new Error('No issuing DID has been configured');

          case 4:
            header = (0, _extends3.default)({}, JOSE_HEADER, { alg: alg || defaultAlg });
            timestamps = { iat: Math.floor(Date.now() / 1000) };

            if (!expiresIn) {
              _context.next = 12;
              break;
            }

            if (!(typeof expiresIn === 'number')) {
              _context.next = 11;
              break;
            }

            timestamps.exp = timestamps.iat + Math.floor(expiresIn);
            _context.next = 12;
            break;

          case 11:
            throw new Error('JWT expiresIn is not a number');

          case 12:
            signingInput = [encodeSection(header), encodeSection((0, _extends3.default)({}, timestamps, payload, { iss: issuer }))].join('.');
            jwtSigner = (0, _SignerAlgorithm2.default)(header.alg);
            _context.next = 16;
            return jwtSigner(signingInput, signer);

          case 16:
            signature = _context.sent;
            return _context.abrupt('return', [signingInput, signature].join('.'));

          case 18:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  return function createJWT(_x, _x2) {
    return _ref2.apply(this, arguments);
  };
}();

/**
*  Verifies given JWT. If the JWT is valid, the promise returns an object including the JWT, the payload of the JWT,
*  and the did doc of the issuer of the JWT.
*
*  @example
*  verifyJWT('did:uport:eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJyZXF1Z....', {audience: '5A8bRWU3F7j3REx3vkJ...', callbackUrl: 'https://...}).then(obj => {
       const did = obj.did // DID of signer
*      const payload = obj.payload
*      const doc = obj.doc // DID Document of signer
*      const jwt = obj.jwt
*      const signerKeyId = obj.signerKeyId // ID of key in DID document that signed JWT
*      ...
*  })
*
*  @param    {String}            jwt                a JSON Web Token to verify
*  @param    {Object}            [config]           an unsigned credential object
*  @param    {Boolean}           config.auth        Require signer to be listed in the authentication section of the DID document (for Authentication purposes)
*  @param    {String}            config.audience    DID of the recipient of the JWT
*  @param    {String}            config.callbackUrl callback url in JWT
*  @return   {Promise<Object, Error>}               a promise which resolves with a response object or rejects with an error
*/


var verifyJWT = exports.verifyJWT = function () {
  var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(jwt) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var aud, _decodeJWT, payload, header, signature, data, _ref4, doc, authenticators, issuer, signer, now;

    return _regenerator2.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            aud = options.audience ? normalizeDID(options.audience) : undefined;
            _decodeJWT = decodeJWT(jwt), payload = _decodeJWT.payload, header = _decodeJWT.header, signature = _decodeJWT.signature, data = _decodeJWT.data;
            _context2.next = 4;
            return resolveAuthenticator(header.alg, payload.iss, options.auth);

          case 4:
            _ref4 = _context2.sent;
            doc = _ref4.doc;
            authenticators = _ref4.authenticators;
            issuer = _ref4.issuer;
            signer = (0, _VerifierAlgorithm2.default)(header.alg)(data, signature, authenticators);
            now = Math.floor(Date.now() / 1000);

            if (!signer) {
              _context2.next = 30;
              break;
            }

            if (!(payload.iat && payload.iat > now + IAT_SKEW)) {
              _context2.next = 13;
              break;
            }

            throw new Error('JWT not valid yet (issued in the future): iat: ' + payload.iat + ' > now: ' + now);

          case 13:
            if (!(payload.exp && payload.exp <= now - IAT_SKEW)) {
              _context2.next = 15;
              break;
            }

            throw new Error('JWT has expired: exp: ' + payload.exp + ' < now: ' + now);

          case 15:
            if (!payload.aud) {
              _context2.next = 27;
              break;
            }

            if (!isDIDOrMNID(payload.aud)) {
              _context2.next = 23;
              break;
            }

            if (aud) {
              _context2.next = 19;
              break;
            }

            throw new Error('JWT audience is required but your app address has not been configured');

          case 19:
            if (!(aud !== normalizeDID(payload.aud))) {
              _context2.next = 21;
              break;
            }

            throw new Error('JWT audience does not match your DID: aud: ' + payload.aud + ' !== yours: ' + aud);

          case 21:
            _context2.next = 27;
            break;

          case 23:
            if (options.callbackUrl) {
              _context2.next = 25;
              break;
            }

            throw new Error('JWT audience matching your callback url is required but one wasn\'t passed in');

          case 25:
            if (!(payload.aud !== options.callbackUrl)) {
              _context2.next = 27;
              break;
            }

            throw new Error('JWT audience does not match the callback url: aud: ' + payload.aud + ' !== url: ' + options.callbackUrl);

          case 27:
            return _context2.abrupt('return', { payload: payload, doc: doc, issuer: issuer, signer: signer, jwt: jwt });

          case 30:
          case 'end':
            return _context2.stop();
        }
      }
    }, _callee2, this);
  }));

  return function verifyJWT(_x4) {
    return _ref3.apply(this, arguments);
  };
}();

/**
* Resolves relevant public keys or other authenticating material used to verify signature from the DID document of provided DID
*
*  @example
*  resolveAuthenticator('ES256K', 'did:uport:2nQtiQG6Cgm1GYTBaaKAgr76uY7iSexUkqX').then(obj => {
*      const payload = obj.payload
*      const profile = obj.profile
*      const jwt = obj.jwt
*      ...
*  })
*
*  @param    {String}            alg                a JWT algorithm
*  @param    {String}            did                a Decentralized IDentifier (DID) to lookup
*  @param    {Boolean}           auth               Restrict public keys to ones specifically listed in the 'authentication' section of DID document
*  @return   {Promise<Object, Error>}               a promise which resolves with a response object containing an array of authenticators or if non exist rejects with an error
*/

var resolveAuthenticator = exports.resolveAuthenticator = function () {
  var _ref5 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(alg, mnidOrDid, auth) {
    var types, issuer, doc, authenticationKeys, authenticators;
    return _regenerator2.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            types = SUPPORTED_PUBLIC_KEY_TYPES[alg];

            if (!(!types || types.length === 0)) {
              _context3.next = 3;
              break;
            }

            throw new Error('No supported signature types for algorithm ' + alg);

          case 3:
            issuer = normalizeDID(mnidOrDid);
            _context3.next = 6;
            return (0, _didResolver2.default)(issuer);

          case 6:
            doc = _context3.sent;

            if (doc) {
              _context3.next = 9;
              break;
            }

            throw new Error('Unable to resolve DID document for ' + issuer);

          case 9:
            authenticationKeys = auth ? (doc.authentication || []).map(function (_ref6) {
              var publicKey = _ref6.publicKey;
              return publicKey;
            }) : true;
            authenticators = (doc.publicKey || []).filter(function (_ref7) {
              var type = _ref7.type,
                  id = _ref7.id;
              return types.find(function (supported) {
                return supported === type && (!auth || authenticationKeys.indexOf(id) >= 0);
              });
            });

            if (!(auth && (!authenticators || authenticators.length === 0))) {
              _context3.next = 13;
              break;
            }

            throw new Error('DID document for ' + issuer + ' does not have public keys suitable for authenticationg user');

          case 13:
            if (!(!authenticators || authenticators.length === 0)) {
              _context3.next = 15;
              break;
            }

            throw new Error('DID document for ' + issuer + ' does not have public keys for ' + alg);

          case 15:
            return _context3.abrupt('return', { authenticators: authenticators, issuer: issuer, doc: doc });

          case 16:
          case 'end':
            return _context3.stop();
        }
      }
    }, _callee3, this);
  }));

  return function resolveAuthenticator(_x5, _x6, _x7) {
    return _ref5.apply(this, arguments);
  };
}();

exports.decodeJWT = decodeJWT;

var _mnid = require('mnid');

var _VerifierAlgorithm = require('./VerifierAlgorithm');

var _VerifierAlgorithm2 = _interopRequireDefault(_VerifierAlgorithm);

var _SignerAlgorithm = require('./SignerAlgorithm');

var _SignerAlgorithm2 = _interopRequireDefault(_SignerAlgorithm);

var _base64url = require('base64url');

var _base64url2 = _interopRequireDefault(_base64url);

var _didResolver = require('did-resolver');

var _didResolver2 = _interopRequireDefault(_didResolver);

var _uportDidResolver = require('uport-did-resolver');

var _uportDidResolver2 = _interopRequireDefault(_uportDidResolver);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

(0, _uportDidResolver2.default)();

var SUPPORTED_PUBLIC_KEY_TYPES = {
  ES256K: ['Secp256k1VerificationKey2018', 'Secp256k1SignatureVerificationKey2018', 'EcdsaPublicKeySecp256k1'],
  'ES256K-R': ['Secp256k1VerificationKey2018', 'Secp256k1SignatureVerificationKey2018', 'EcdsaPublicKeySecp256k1']
};

var JOSE_HEADER = { typ: 'JWT' };
var defaultAlg = 'ES256K';

function encodeSection(data) {
  return _base64url2.default.encode((0, _stringify2.default)(data));
}

var IAT_SKEW = exports.IAT_SKEW = 60;

/**  @module did-jwt/JWT */

function isDIDOrMNID(mnidOrDid) {
  return mnidOrDid && (mnidOrDid.match(/^did:/) || (0, _mnid.isMNID)(mnidOrDid));
}

function normalizeDID(mnidOrDid) {
  if (mnidOrDid.match(/^did:/)) return mnidOrDid;
  if ((0, _mnid.isMNID)(mnidOrDid)) return 'did:uport:' + mnidOrDid;
  throw new Error('Not a valid DID \'' + mnidOrDid + '\'');
}

function decodeJWT(jwt) {
  if (!jwt) throw new Error('no JWT passed into decodeJWT');
  var parts = jwt.match(/^([a-zA-Z0-9_-]+)\.([a-zA-Z0-9_-]+)\.([a-zA-Z0-9_-]+)$/);
  if (parts) {
    return {
      header: JSON.parse(_base64url2.default.decode(parts[1])),
      payload: JSON.parse(_base64url2.default.decode(parts[2])),
      signature: parts[3],
      data: parts[1] + '.' + parts[2]
    };
  }
  throw new Error('Incorrect format JWT');
}exports.default = { decodeJWT: decodeJWT, createJWT: createJWT, verifyJWT: verifyJWT, resolveAuthenticator: resolveAuthenticator };