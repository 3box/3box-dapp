'use strict';

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _VerifierAlgorithm = require('../VerifierAlgorithm');

var _VerifierAlgorithm2 = _interopRequireDefault(_VerifierAlgorithm);

var _JWT = require('../JWT');

var _SimpleSigner = require('../SimpleSigner');

var _SimpleSigner2 = _interopRequireDefault(_SimpleSigner);

var _base64url = require('base64url');

var _base64url2 = _interopRequireDefault(_base64url);

var _Digest = require('../Digest');

var _elliptic = require('elliptic');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var secp256k1 = new _elliptic.ec('secp256k1');

describe('VerifierAlgorithm', function () {
  it('supports ES256K', function () {
    expect((0, _typeof3.default)((0, _VerifierAlgorithm2.default)('ES256K'))).toEqual('function');
  });

  it('supports ES256K-R', function () {
    expect((0, _typeof3.default)((0, _VerifierAlgorithm2.default)('ES256K-R'))).toEqual('function');
  });

  it('fails on unsupported algorithm', function () {
    expect(function () {
      return (0, _VerifierAlgorithm2.default)('BADALGO');
    }).toThrowError('Unsupported algorithm BADALGO');
  });
});

var mnid = '2nQtiQG6Cgm1GYTBaaKAgr76uY7iSexUkqX';
var did = 'did:uport:' + mnid;
var privateKey = '278a5de700e29faae8e40e366ec5012b5ec63d36ec77e8a2417154cc1d25383f';
var kp = secp256k1.keyFromPrivate(privateKey);
var publicKey = kp.getPublic('hex');
var compressedPublicKey = kp.getPublic().encode('hex', true);
var address = (0, _Digest.toEthereumAddress)(publicKey);
var signer = (0, _SimpleSigner2.default)(privateKey);

var ecKey1 = {
  id: did + '#keys-1',
  type: 'Secp256k1VerificationKey2018',
  owner: did,
  publicKeyHex: '04613bb3a4874d27032618f020614c21cbe4c4e4781687525f6674089f9bd3d6c7f6eb13569053d31715a3ba32e0b791b97922af6387f087d6b5548c06944ab062'
};

var ecKey2 = {
  id: did + '#keys-2',
  type: 'Secp256k1VerificationKey2018',
  owner: did,
  publicKeyHex: publicKey
};

var ethAddress = {
  id: did + '#keys-3',
  type: 'Secp256k1VerificationKey2018',
  owner: did,
  ethereumAddress: address
};

var compressedKey = {
  id: did + '#keys-4',
  type: 'Secp256k1VerificationKey2018',
  owner: did,
  publicKeyHex: compressedPublicKey
};

describe('ES256K', function () {
  var verifier = (0, _VerifierAlgorithm2.default)('ES256K');
  it('validates signature and picks correct public key', (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
    var jwt, parts;
    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return (0, _JWT.createJWT)({ bla: 'bla' }, { issuer: did, signer: signer });

          case 2:
            jwt = _context.sent;
            parts = jwt.match(/^([a-zA-Z0-9_-]+\.[a-zA-Z0-9_-]+)\.([a-zA-Z0-9_-]+)$/);
            return _context.abrupt('return', expect(verifier(parts[1], parts[2], [ecKey1, ecKey2])).toEqual(ecKey2));

          case 5:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, undefined);
  })));

  it('validates signature with compressed public key and picks correct public key', (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2() {
    var jwt, parts;
    return _regenerator2.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return (0, _JWT.createJWT)({ bla: 'bla' }, { issuer: did, signer: signer });

          case 2:
            jwt = _context2.sent;
            parts = jwt.match(/^([a-zA-Z0-9_-]+\.[a-zA-Z0-9_-]+)\.([a-zA-Z0-9_-]+)$/);
            return _context2.abrupt('return', expect(verifier(parts[1], parts[2], [ecKey1, compressedKey])).toEqual(compressedKey));

          case 5:
          case 'end':
            return _context2.stop();
        }
      }
    }, _callee2, undefined);
  })));

  it('throws error if invalid signature', (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3() {
    var jwt, parts;
    return _regenerator2.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return (0, _JWT.createJWT)({ bla: 'bla' }, { issuer: did, signer: signer });

          case 2:
            jwt = _context3.sent;
            parts = jwt.match(/^([a-zA-Z0-9_-]+\.[a-zA-Z0-9_-]+)\.([a-zA-Z0-9_-]+)$/);
            return _context3.abrupt('return', expect(function () {
              return verifier(parts[1], parts[2], [ecKey1]);
            }).toThrowError(new Error('Signature invalid for JWT')));

          case 5:
          case 'end':
            return _context3.stop();
        }
      }
    }, _callee3, undefined);
  })));
});

describe('ES256K-R', (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee8() {
  var verifier;
  return _regenerator2.default.wrap(function _callee8$(_context8) {
    while (1) {
      switch (_context8.prev = _context8.next) {
        case 0:
          verifier = (0, _VerifierAlgorithm2.default)('ES256K-R');


          it('validates signature and picks correct public key', (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4() {
            var jwt, parts;
            return _regenerator2.default.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    _context4.next = 2;
                    return (0, _JWT.createJWT)({ bla: 'bla' }, { issuer: did, signer: signer, alg: 'ES256K-R' });

                  case 2:
                    jwt = _context4.sent;
                    parts = jwt.match(/^([a-zA-Z0-9_-]+\.[a-zA-Z0-9_-]+)\.([a-zA-Z0-9_-]+)$/);
                    return _context4.abrupt('return', expect(verifier(parts[1], parts[2], [ecKey1, ecKey2])).toEqual(ecKey2));

                  case 5:
                  case 'end':
                    return _context4.stop();
                }
              }
            }, _callee4, undefined);
          })));

          it('validates signature and picks correct compressed public key', (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee5() {
            var jwt, parts;
            return _regenerator2.default.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    _context5.next = 2;
                    return (0, _JWT.createJWT)({ bla: 'bla' }, { issuer: did, signer: signer, alg: 'ES256K-R' });

                  case 2:
                    jwt = _context5.sent;
                    parts = jwt.match(/^([a-zA-Z0-9_-]+\.[a-zA-Z0-9_-]+)\.([a-zA-Z0-9_-]+)$/);
                    return _context5.abrupt('return', expect(verifier(parts[1], parts[2], [ecKey1, compressedKey])).toEqual(compressedKey));

                  case 5:
                  case 'end':
                    return _context5.stop();
                }
              }
            }, _callee5, undefined);
          })));

          it('validates signature with ethereum address', (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee6() {
            var jwt, parts;
            return _regenerator2.default.wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    _context6.next = 2;
                    return (0, _JWT.createJWT)({ bla: 'bla' }, { issuer: did, signer: signer, alg: 'ES256K-R' });

                  case 2:
                    jwt = _context6.sent;
                    parts = jwt.match(/^([a-zA-Z0-9_-]+\.[a-zA-Z0-9_-]+)\.([a-zA-Z0-9_-]+)$/);
                    return _context6.abrupt('return', expect(verifier(parts[1], parts[2], [ecKey1, ethAddress])).toEqual(ethAddress));

                  case 5:
                  case 'end':
                    return _context6.stop();
                }
              }
            }, _callee6, undefined);
          })));

          it('throws error if invalid signature', (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee7() {
            var jwt, parts;
            return _regenerator2.default.wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    _context7.next = 2;
                    return (0, _JWT.createJWT)({ bla: 'bla' }, { issuer: did, signer: signer, alg: 'ES256K-R' });

                  case 2:
                    jwt = _context7.sent;
                    parts = jwt.match(/^([a-zA-Z0-9_-]+\.[a-zA-Z0-9_-]+)\.([a-zA-Z0-9_-]+)$/);
                    return _context7.abrupt('return', expect(function () {
                      return verifier(parts[1], parts[2], [ecKey1]);
                    }).toThrowError(new Error('Signature invalid for JWT')));

                  case 5:
                  case 'end':
                    return _context7.stop();
                }
              }
            }, _callee7, undefined);
          })));

        case 5:
        case 'end':
          return _context8.stop();
      }
    }
  }, _callee8, undefined);
})));