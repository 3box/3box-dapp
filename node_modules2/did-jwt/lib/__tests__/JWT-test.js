'use strict';

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _JWT = require('../JWT');

var _jsontokens = require('jsontokens');

var _uportDidResolver = require('uport-did-resolver');

var _uportDidResolver2 = _interopRequireDefault(_uportDidResolver);

var _SimpleSigner = require('../SimpleSigner');

var _SimpleSigner2 = _interopRequireDefault(_SimpleSigner);

var _mockdate = require('mockdate');

var _mockdate2 = _interopRequireDefault(_mockdate);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var NOW = 1485321133;
_mockdate2.default.set(NOW * 1000 + 123);

var audMnid = '2nQtiQG6Cgm1GYTBaaKAgr76uY7iSexUkqY';
var aud = 'did:uport:' + audMnid;
var mnid = '2nQtiQG6Cgm1GYTBaaKAgr76uY7iSexUkqX';
var did = 'did:uport:' + mnid;
var alg = 'ES256K';

var privateKey = '278a5de700e29faae8e40e366ec5012b5ec63d36ec77e8a2417154cc1d25383f';
var publicKey = '03fdd57adec3d438ea237fe46b33ee1e016eda6b585c3e27ea66686c2ea5358479';
var verifier = new _jsontokens.TokenVerifier(alg, publicKey);
var signer = (0, _SimpleSigner2.default)(privateKey);

var didDoc = {
  '@context': 'https://w3id.org/did/v1',
  id: did,
  publicKey: [{
    id: did + '#keys-1',
    type: 'Secp256k1VerificationKey2018',
    owner: did,
    publicKeyHex: publicKey
  }],
  authentication: [{
    type: 'Secp256k1SignatureAuthentication2018',
    publicKey: did + '#keys-1'
  }]
};

var ethDidDoc = {
  '@context': 'https://w3id.org/did/v1',
  id: did,
  publicKey: [{
    id: did + '#keys-1',
    type: 'Secp256k1VerificationKey2018',
    owner: did,
    ethereumAddress: '0xf3beac30c498d9e26865f34fcaa57dbb935b0d74'
  }]
};

describe('createJWT()', function () {
  it('creates a valid JWT', function () {
    return (0, _JWT.createJWT)({ requested: ['name', 'phone'] }, { issuer: did, signer: signer }).then(function (jwt) {
      return expect(verifier.verify(jwt)).toBeTruthy();
    });
  });

  it('creates a valid JWT using a MNID', function () {
    return (0, _JWT.createJWT)({ requested: ['name', 'phone'] }, { issuer: mnid, signer: signer }).then(function (jwt) {
      return expect(verifier.verify(jwt)).toBeTruthy();
    });
  });

  it('creates a JWT with correct format', function () {
    return (0, _JWT.createJWT)({ requested: ['name', 'phone'] }, { issuer: did, signer: signer }).then(function (jwt) {
      return expect((0, _JWT.decodeJWT)(jwt)).toMatchSnapshot();
    });
  });

  it('creates a JWT with correct legacy format', function () {
    return (0, _JWT.createJWT)({ requested: ['name', 'phone'] }, { issuer: mnid, signer: signer }).then(function (jwt) {
      return expect((0, _JWT.decodeJWT)(jwt)).toMatchSnapshot();
    });
  });

  it('creates a JWT with expiry in 10000 seconds', function () {
    return (0, _JWT.createJWT)({ requested: ['name', 'phone'] }, { issuer: did, signer: signer, expiresIn: 10000 }).then(function (jwt) {
      var _decodeJWT = (0, _JWT.decodeJWT)(jwt),
          payload = _decodeJWT.payload;

      return expect(payload.exp).toEqual(payload.iat + 10000);
    });
  });

  it('throws an error if no signer is configured', function () {
    return (0, _JWT.createJWT)({ requested: ['name', 'phone'] }, { issuer: did }).catch(function (error) {
      return expect(error.message).toEqual('No Signer functionality has been configured');
    });
  });

  it('throws an error if no address is configured', function () {
    return (0, _JWT.createJWT)({ requested: ['name', 'phone'] }, { signer: signer }).catch(function (error) {
      return expect(error.message).toEqual('No issuing DID has been configured');
    });
  });

  it('throws an error if unsupported algorithm is passed in', function () {
    return (0, _JWT.createJWT)({ requested: ['name', 'phone'] }, { issuer: did, signer: signer, alg: 'BADALGO' }).catch(function (error) {
      return expect(error.message).toEqual('Unsupported algorithm BADALGO');
    });
  });
});

describe('verifyJWT()', function () {
  (0, _uportDidResolver2.default)(function (id, cb) {
    if (mnid === id) cb(null, didDoc);
    if (audMnid === id) cb(null, ethDidDoc);
  });
  var incomingJwt = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJpc3MiOiJkaWQ6dXBvcnQ6Mm5RdGlRRzZDZ20xR1lUQmFhS0Fncjc2dVk3aVNleFVrcVgiLCJpYXQiOjE0ODUzMjExMzMsInJlcXVlc3RlZCI6WyJuYW1lIiwicGhvbmUiXX0.1hyeUGRBb-cgvjD5KKbpVJBF4TfDjYxrI8SWRJ-GyrJrNLAxt4MutKMFQyF1k_YkxbVozGJ_4XmgZqNaW4OvCw';

  it('verifies the JWT and return correct payload', function () {
    return (0, _JWT.verifyJWT)(incomingJwt).then(function (_ref) {
      var payload = _ref.payload;

      return expect(payload).toMatchSnapshot();
    });
  });

  it('verifies the JWT and return correct profile', function () {
    return (0, _JWT.verifyJWT)(incomingJwt).then(function (_ref2) {
      var doc = _ref2.doc;

      return expect(doc).toEqual(didDoc);
    });
  });

  it('verifies the JWT and return correct did for the iss', function () {
    return (0, _JWT.verifyJWT)(incomingJwt).then(function (_ref3) {
      var issuer = _ref3.issuer;

      return expect(issuer).toEqual(did);
    });
  });

  it('verifies the JWT and return correct signer', function () {
    return (0, _JWT.verifyJWT)(incomingJwt).then(function (_ref4) {
      var signer = _ref4.signer;
      return expect(signer).toEqual(didDoc.publicKey[0]);
    });
  });

  it('verifies the JWT requiring authentication and return correct signer', function () {
    return (0, _JWT.verifyJWT)(incomingJwt, { auth: true }).then(function (_ref5) {
      var signer = _ref5.signer;
      return expect(signer).toEqual(didDoc.publicKey[0]);
    });
  });

  var badJwt = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NksifQ.eyJpc3MiOiJkaWQ6dXBvcnQ6Mm5RdGlRRzZDZ20xR1lUQmFhS0Fncjc2dVk3aVNleFVrcVgiLCJpYXQiOjE0ODUzMjExMzMsInJlcXVlc3RlZCI6WyJuYW1lIiwicGhvbmUiXX0.1hyeUGRBb-cgvjD5KKbpVJBF4TfDjYxrI8SWRJ-GyrJrNLAxt4MutKMFQyF1k_YkxbVozGJ_4XmgZqNaW4OvCX';
  it('rejects a JWT with bad signature', function () {
    return (0, _JWT.verifyJWT)(badJwt).catch(function (error) {
      return expect(error.message).toEqual('Signature invalid for JWT');
    }).then(function (p) {
      return expect(p).toBeFalsy();
    });
  });

  it('accepts a valid iat', function () {
    return (0, _JWT.createJWT)({ iat: NOW + _JWT.IAT_SKEW }, { issuer: did, signer: signer }).then(function (jwt) {
      return (0, _JWT.verifyJWT)(jwt).then(function (_ref6) {
        var payload = _ref6.payload;
        return expect(payload).toMatchSnapshot();
      }, function (error) {
        return expect(error).toBeNull();
      });
    });
  });

  it('handles ES256K-R algorithm', function () {
    return (0, _JWT.createJWT)({ hello: 'world' }, { issuer: did, signer: signer, alg: 'ES256K-R' }).then(function (jwt) {
      return (0, _JWT.verifyJWT)(jwt).then(function (_ref7) {
        var payload = _ref7.payload;
        return expect(payload).toMatchSnapshot();
      }, function (error) {
        return expect(error).toBeNull();
      });
    });
  });

  it('handles ES256K-R algorithm with ethereum address', function () {
    return (0, _JWT.createJWT)({ hello: 'world' }, { issuer: aud, signer: signer, alg: 'ES256K-R' }).then(function (jwt) {
      return (0, _JWT.verifyJWT)(jwt).then(function (_ref8) {
        var payload = _ref8.payload;
        return expect(payload).toMatchSnapshot();
      }, function (error) {
        return expect(error).toBeNull();
      });
    });
  });

  it('rejects an iat in the future', function () {
    return (0, _JWT.createJWT)({ iat: NOW + _JWT.IAT_SKEW + 1 }, { issuer: did, signer: signer }).then(function (jwt) {
      return (0, _JWT.verifyJWT)(jwt).catch(function (error) {
        return expect(error.message).toEqual('JWT not valid yet (issued in the future): iat: 1485321194 > now: 1485321133');
      }).then(function (p) {
        return expect(p).toBeFalsy();
      });
    });
  });

  it('accepts a valid exp', function () {
    return (0, _JWT.createJWT)({ exp: NOW - _JWT.IAT_SKEW + 1 }, { issuer: did, signer: signer, expiresIn: 1 }).then(function (jwt) {
      return (0, _JWT.verifyJWT)(jwt).then(function (_ref9) {
        var payload = _ref9.payload;
        return expect(payload).toMatchSnapshot();
      });
    });
  });

  it('rejects an expired JWT', function () {
    return (0, _JWT.createJWT)({ exp: NOW - _JWT.IAT_SKEW - 1 }, { issuer: did, signer: signer }).then(function (jwt) {
      return (0, _JWT.verifyJWT)(jwt).catch(function (error) {
        return expect(error.message).toEqual('JWT has expired: exp: 1485321072 < now: 1485321133');
      }).then(function (p) {
        return expect(p).toBeFalsy();
      });
    });
  });

  it('accepts a valid audience', function () {
    return (0, _JWT.createJWT)({ aud: aud }, { issuer: did, signer: signer }).then(function (jwt) {
      return (0, _JWT.verifyJWT)(jwt, { audience: aud }).then(function (_ref10) {
        var payload = _ref10.payload;
        return expect(payload).toMatchSnapshot();
      });
    });
  });

  it('accepts a valid MNID audience', function () {
    return (0, _JWT.createJWT)({ aud: aud }, { issuer: did, signer: signer }).then(function (jwt) {
      return (0, _JWT.verifyJWT)(jwt, { audience: audMnid }).then(function (_ref11) {
        var payload = _ref11.payload;
        return expect(payload).toMatchSnapshot();
      });
    });
  });

  it('accepts a valid audience using callback_url', function () {
    return (0, _JWT.createJWT)({ aud: 'http://pututu.uport.me/unique' }, { issuer: did, signer: signer }).then(function (jwt) {
      return (0, _JWT.verifyJWT)(jwt, { callbackUrl: 'http://pututu.uport.me/unique' }).then(function (_ref12) {
        var payload = _ref12.payload;
        return expect(payload).toMatchSnapshot();
      });
    });
  });

  it('rejects invalid audience', function () {
    return (0, _JWT.createJWT)({ aud: aud }, { issuer: did, signer: signer }).then(function (jwt) {
      return (0, _JWT.verifyJWT)(jwt, { audience: did }).catch(function (error) {
        return expect(error.message).toEqual('JWT audience does not match your DID: aud: did:uport:2nQtiQG6Cgm1GYTBaaKAgr76uY7iSexUkqY !== yours: did:uport:2nQtiQG6Cgm1GYTBaaKAgr76uY7iSexUkqX');
      }).then(function (p) {
        return expect(p).toBeFalsy();
      });
    });
  });

  it('rejects an invalid audience using callback_url where callback is wrong', function () {
    return (0, _JWT.createJWT)({ aud: 'http://pututu.uport.me/unique' }, { issuer: did, signer: signer }).then(function (jwt) {
      return (0, _JWT.verifyJWT)(jwt, { callbackUrl: 'http://pututu.uport.me/unique/1' }).catch(function (error) {
        return expect(error.message).toEqual('JWT audience does not match the callback url: aud: http://pututu.uport.me/unique !== url: http://pututu.uport.me/unique/1');
      });
    });
  });

  it('rejects an invalid audience using callback_url where callback is missing', function () {
    return (0, _JWT.createJWT)({ aud: 'http://pututu.uport.me/unique' }, { issuer: did, signer: signer }).then(function (jwt) {
      return (0, _JWT.verifyJWT)(jwt).catch(function (error) {
        return expect(error.message).toEqual('JWT audience matching your callback url is required but one wasn\'t passed in');
      });
    });
  });

  it('rejects invalid audience as no address is present', function () {
    return (0, _JWT.createJWT)({ aud: aud }, { issuer: did, signer: signer }).then(function (jwt) {
      return (0, _JWT.verifyJWT)(jwt).catch(function (error) {
        return expect(error.message).toEqual('JWT audience is required but your app address has not been configured');
      }).then(function (p) {
        return expect(p).toBeFalsy();
      });
    });
  });
});

describe('resolveAuthenticator()', function () {
  var ecKey1 = {
    id: did + '#keys-1',
    type: 'Secp256k1VerificationKey2018',
    owner: did,
    publicKeyHex: '04613bb3a4874d27032618f020614c21cbe4c4e4781687525f6674089f9bd3d6c7f6eb13569053d31715a3ba32e0b791b97922af6387f087d6b5548c06944ab061'
  };

  var ecKey2 = {
    id: did + '#keys-2',
    type: 'Secp256k1SignatureVerificationKey2018',
    owner: did,
    publicKeyHex: '04613bb3a4874d27032618f020614c21cbe4c4e4781687525f6674089f9bd3d6c7f6eb13569053d31715a3ba32e0b791b97922af6387f087d6b5548c06944ab062'
  };

  var ecKey3 = {
    id: did + '#keys-3',
    type: 'Secp256k1SignatureVerificationKey2018',
    owner: did,
    publicKeyHex: '04613bb3a4874d27032618f020614c21cbe4c4e4781687525f6674089f9bd3d6c7f6eb13569053d31715a3ba32e0b791b97922af6387f087d6b5548c06944ab063'
  };

  var encKey1 = {
    id: did + '#keys-3',
    type: 'Curve25519EncryptionPublicKey',
    owner: did,
    publicKeyBase64: 'QCFPBLm5pwmuTOu+haxv0+Vpmr6Rrz/DEEvbcjktQnQ='
  };

  var authKey1 = {
    type: 'Secp256k1SignatureAuthentication2018',
    publicKey: ecKey1.id
  };

  var authKey2 = {
    type: 'Secp256k1SignatureAuthentication2018',
    publicKey: ecKey2.id
  };

  var singleKey = {
    '@context': 'https://w3id.org/did/v1',
    id: did,
    publicKey: [ecKey1]
  };

  var multipleKeys = {
    '@context': 'https://w3id.org/did/v1',
    id: did,
    publicKey: [ecKey1, ecKey2, ecKey3, encKey1],
    authentication: [authKey1, authKey2]
  };

  var unsupportedFormat = {
    '@context': 'https://w3id.org/did/v1',
    id: did,
    publicKey: [encKey1]
  };
  var noPublicKey = {
    '@context': 'https://w3id.org/did/v1',
    id: did
  };

  describe('DID', function () {
    it('finds public key', (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
      var authenticators;
      return _regenerator2.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              (0, _uportDidResolver2.default)(function (mnid, cb) {
                return cb(null, singleKey);
              });
              _context.next = 3;
              return (0, _JWT.resolveAuthenticator)(alg, did);

            case 3:
              authenticators = _context.sent;
              return _context.abrupt('return', expect(authenticators).toEqual({ authenticators: [ecKey1], issuer: did, doc: singleKey }));

            case 5:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, undefined);
    })));

    it('filters out irrelevant public keys', (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2() {
      var authenticators;
      return _regenerator2.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              (0, _uportDidResolver2.default)(function (mnid, cb) {
                return cb(null, multipleKeys);
              });
              _context2.next = 3;
              return (0, _JWT.resolveAuthenticator)(alg, did);

            case 3:
              authenticators = _context2.sent;
              return _context2.abrupt('return', expect(authenticators).toEqual({ authenticators: [ecKey1, ecKey2, ecKey3], issuer: did, doc: multipleKeys }));

            case 5:
            case 'end':
              return _context2.stop();
          }
        }
      }, _callee2, undefined);
    })));

    it('only list authenticators able to authenticate a user', (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3() {
      var authenticators;
      return _regenerator2.default.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              (0, _uportDidResolver2.default)(function (mnid, cb) {
                return cb(null, multipleKeys);
              });
              _context3.next = 3;
              return (0, _JWT.resolveAuthenticator)(alg, did, true);

            case 3:
              authenticators = _context3.sent;
              return _context3.abrupt('return', expect(authenticators).toEqual({ authenticators: [ecKey1, ecKey2], issuer: did, doc: multipleKeys }));

            case 5:
            case 'end':
              return _context3.stop();
          }
        }
      }, _callee3, undefined);
    })));

    it('errors if no suitable public keys exist', (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4() {
      return _regenerator2.default.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              (0, _uportDidResolver2.default)(function (mnid, cb) {
                return cb(null, unsupportedFormat);
              });
              return _context4.abrupt('return', expect((0, _JWT.resolveAuthenticator)(alg, did)).rejects.toEqual(new Error('DID document for ' + did + ' does not have public keys for ' + alg)));

            case 2:
            case 'end':
              return _context4.stop();
          }
        }
      }, _callee4, undefined);
    })));

    it('errors if no suitable public keys exist for authentication', (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee5() {
      return _regenerator2.default.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              (0, _uportDidResolver2.default)(function (mnid, cb) {
                return cb(null, singleKey);
              });
              return _context5.abrupt('return', expect((0, _JWT.resolveAuthenticator)(alg, did, true)).rejects.toEqual(new Error('DID document for ' + did + ' does not have public keys suitable for authenticationg user')));

            case 2:
            case 'end':
              return _context5.stop();
          }
        }
      }, _callee5, undefined);
    })));

    it('errors if no public keys exist', (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee6() {
      return _regenerator2.default.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              (0, _uportDidResolver2.default)(function (mnid, cb) {
                return cb(null, noPublicKey);
              });
              return _context6.abrupt('return', expect((0, _JWT.resolveAuthenticator)(alg, did)).rejects.toEqual(new Error('DID document for ' + did + ' does not have public keys for ' + alg)));

            case 2:
            case 'end':
              return _context6.stop();
          }
        }
      }, _callee6, undefined);
    })));

    it('errors if no DID document exists', (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee7() {
      return _regenerator2.default.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              (0, _uportDidResolver2.default)(function (mnid, cb) {
                return cb(null, null);
              });
              return _context7.abrupt('return', expect((0, _JWT.resolveAuthenticator)(alg, did)).rejects.toEqual(new Error('Unable to resolve DID document for ' + did)));

            case 2:
            case 'end':
              return _context7.stop();
          }
        }
      }, _callee7, undefined);
    })));

    it('errors if no supported signature types exist', (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee8() {
      return _regenerator2.default.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              (0, _uportDidResolver2.default)(function (mnid, cb) {
                return cb(null, singleKey);
              });
              return _context8.abrupt('return', expect((0, _JWT.resolveAuthenticator)('ESBAD', did)).rejects.toEqual(new Error('No supported signature types for algorithm ESBAD')));

            case 2:
            case 'end':
              return _context8.stop();
          }
        }
      }, _callee8, undefined);
    })));
  });

  describe('MNID', function () {
    it('converts MNID to DID and finds public key', (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee9() {
      var authenticators;
      return _regenerator2.default.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              (0, _uportDidResolver2.default)(function (mnid, cb) {
                return cb(null, singleKey);
              });
              _context9.next = 3;
              return (0, _JWT.resolveAuthenticator)(alg, mnid);

            case 3:
              authenticators = _context9.sent;
              return _context9.abrupt('return', expect(authenticators).toEqual({ authenticators: [ecKey1], issuer: did, doc: singleKey }));

            case 5:
            case 'end':
              return _context9.stop();
          }
        }
      }, _callee9, undefined);
    })));
  });
});