'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toSignatureObject = toSignatureObject;
exports.verifyES256K = verifyES256K;
exports.verifyRecoverableES256K = verifyRecoverableES256K;

var _elliptic = require('elliptic');

var _Digest = require('./Digest');

var _base64url = require('base64url');

var _base64url2 = _interopRequireDefault(_base64url);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var secp256k1 = new _elliptic.ec('secp256k1');

// converts a JOSE signature to it's components
function toSignatureObject(signature) {
  var recoverable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var rawsig = _base64url2.default.toBuffer(signature);
  if (rawsig.length !== (recoverable ? 65 : 64)) throw new Error('wrong signature length');
  var r = rawsig.slice(0, 32).toString('hex');
  var s = rawsig.slice(32, 64).toString('hex');
  var sigObj = { r: r, s: s };
  if (recoverable) {
    sigObj.recoveryParam = rawsig[64];
  }
  return sigObj;
}

function verifyES256K(data, signature, authenticators) {
  var hash = (0, _Digest.sha256)(data);
  var sigObj = toSignatureObject(signature);
  var signer = authenticators.find(function (_ref) {
    var publicKeyHex = _ref.publicKeyHex;
    return secp256k1.keyFromPublic(publicKeyHex, 'hex').verify(hash, sigObj);
  });
  if (!signer) throw new Error('Signature invalid for JWT');
  return signer;
}

function verifyRecoverableES256K(data, signature, authenticators) {
  var sigObj = toSignatureObject(signature, true);
  var hash = (0, _Digest.sha256)(data);
  var recoveredKey = secp256k1.recoverPubKey(hash, sigObj, sigObj.recoveryParam);
  var recoveredPublicKeyHex = recoveredKey.encode('hex');
  var recoveredCompressedPublicKeyHex = recoveredKey.encode('hex', true);
  var recoveredAddress = (0, _Digest.toEthereumAddress)(recoveredPublicKeyHex);
  var signer = authenticators.find(function (_ref2) {
    var publicKeyHex = _ref2.publicKeyHex,
        ethereumAddress = _ref2.ethereumAddress;
    return publicKeyHex === recoveredPublicKeyHex || publicKeyHex === recoveredCompressedPublicKeyHex || ethereumAddress === recoveredAddress;
  });
  if (!signer) throw new Error('Signature invalid for JWT');
  return signer;
}

var algorithms = { ES256K: verifyES256K, 'ES256K-R': verifyRecoverableES256K };

function VerifierAlgorithm(alg) {
  var impl = algorithms[alg];
  if (!impl) throw new Error('Unsupported algorithm ' + alg);
  return impl;
}

VerifierAlgorithm.toSignatureObject = toSignatureObject;

module.exports = VerifierAlgorithm;