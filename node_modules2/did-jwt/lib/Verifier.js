'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ES256KVerifier = ES256KVerifier;

var _elliptic = require('elliptic');

var _jsSha = require('js-sha256');

var _base64url = require('base64url');

var _base64url2 = _interopRequireDefault(_base64url);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ES256KVerifier() {
  var secp256k1 = new _elliptic.ec('secp256k1');
  function hash(jwt) {
    var parts = jwt.match(/^([a-zA-Z0-9_-]+\.[a-zA-Z0-9_-]+)\./);
    return Buffer.from(_jsSha.sha256.arrayBuffer(parts[1]));
  }

  function toSignatureObject(signature) {
    var rawsig = _base64url2.default.toBuffer(signature);
    if (rawsig.length !== 64) throw new Error('wrong signature length');
    var r = rawsig.slice(0, 32).toString('hex');
    var s = rawsig.slice(32).toString('hex');
    return { r: r, s: s };
  }

  return function verify(jwt, payload, signature, authenticators) {
    return authenticators.find(function (_ref) {
      var publicKeyHex = _ref.publicKeyHex;
      return secp256k1.keyFromPublic(publicKeyHex, 'hex').verify(hash(jwt), toSignatureObject(signature));
    });
  };
}

var algorithms = { ES256K: ES256KVerifier() };

function Verifier(alg) {
  var impl = algorithms[alg];
  if (!impl) throw new Error('Unsupported algorithm ' + alg);
  return impl;
}

module.exports = Verifier;